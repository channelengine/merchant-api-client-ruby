=begin
#ChannelEngine Merchant API

#ChannelEngine API for merchants

The version of the OpenAPI document: 2.11.0

Generated by: https://openapi-generator.tech
OpenAPI Generator version: 6.0.0-SNAPSHOT

=end

require 'cgi'

module ChannelEngineMerchantApiClient
  class ProductApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # Delete multiple Products.
    # Delete the products based on the merchant references.<br />Note that we do not really delete products, as the products<br />might still be referenced by orders. Therefore, the references<br />used for these products cannot be reused. We do however deactivate the products<br />which means that they will not be sent to channels.
    # @param request_body [Array<String>] The list of MerchantProductNo of the products you wish to delete.
    # @param [Hash] opts the optional parameters
    # @return [ApiResponse]
    def product_bulk_delete(request_body, opts = {})
      data, _status_code, _headers = product_bulk_delete_with_http_info(request_body, opts)
      data
    end

    # Delete multiple Products.
    # Delete the products based on the merchant references.&lt;br /&gt;Note that we do not really delete products, as the products&lt;br /&gt;might still be referenced by orders. Therefore, the references&lt;br /&gt;used for these products cannot be reused. We do however deactivate the products&lt;br /&gt;which means that they will not be sent to channels.
    # @param request_body [Array<String>] The list of MerchantProductNo of the products you wish to delete.
    # @param [Hash] opts the optional parameters
    # @return [Array<(ApiResponse, Integer, Hash)>] ApiResponse data, response status code and response headers
    def product_bulk_delete_with_http_info(request_body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ProductApi.product_bulk_delete ...'
      end
      # verify the required parameter 'request_body' is set
      if @api_client.config.client_side_validation && request_body.nil?
        fail ArgumentError, "Missing the required parameter 'request_body' when calling ProductApi.product_bulk_delete"
      end
      # resource path
      local_var_path = '/v2/products/bulkdelete'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json-patch+json', 'application/json', 'application/*+json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(request_body)

      # return_type
      return_type = opts[:debug_return_type] || 'ApiResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['apiKey']

      new_options = opts.merge(
        :operation => :"ProductApi.product_bulk_delete",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ProductApi#product_bulk_delete\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Bulk Patch Products
    # This endpoint allows you to update multiple fields on a multiple products.<br />Products sent in a request can only be updated for the fields listed in object 'PropertiesToUpdate'. <br />In other words, you specify which products you want to update and which fields should be updated for all products.<br /><br />Sample request:<br /><br /> PATCH /v2/products<br /> {<br /> \"PropertiesToUpdate\": [<br /> \"name\",<br /> \"description\"<br /> ],<br /> \"MerchantProductRequestModels\": [<br /> {<br /> \"MerchantProductNo\": \"testMerchantProductNo\",<br /> \"Name\": \"testName\",<br /> \"Description\": \"testDescription\",<br /> },<br /> {<br /> \"MerchantProductNo\": \"testMerchantProductNo2\",<br /> \"Name\": \"testName3\",<br /> \"Description\": \"testDescription1\",<br /> }<br /> ]<br /> }
    # @param [Hash] opts the optional parameters
    # @option opts [PatchMerchantProductDto] :patch_merchant_product_dto 1) PropertiesToUpdate: Fields to update&lt;br /&gt;2) MerchantProductRequestModels: Products to be updated
    # @return [SingleOfProductCreationResult]
    def product_bulk_patch(opts = {})
      data, _status_code, _headers = product_bulk_patch_with_http_info(opts)
      data
    end

    # Bulk Patch Products
    # This endpoint allows you to update multiple fields on a multiple products.&lt;br /&gt;Products sent in a request can only be updated for the fields listed in object &#39;PropertiesToUpdate&#39;. &lt;br /&gt;In other words, you specify which products you want to update and which fields should be updated for all products.&lt;br /&gt;&lt;br /&gt;Sample request:&lt;br /&gt;&lt;br /&gt; PATCH /v2/products&lt;br /&gt; {&lt;br /&gt; \&quot;PropertiesToUpdate\&quot;: [&lt;br /&gt; \&quot;name\&quot;,&lt;br /&gt; \&quot;description\&quot;&lt;br /&gt; ],&lt;br /&gt; \&quot;MerchantProductRequestModels\&quot;: [&lt;br /&gt; {&lt;br /&gt; \&quot;MerchantProductNo\&quot;: \&quot;testMerchantProductNo\&quot;,&lt;br /&gt; \&quot;Name\&quot;: \&quot;testName\&quot;,&lt;br /&gt; \&quot;Description\&quot;: \&quot;testDescription\&quot;,&lt;br /&gt; },&lt;br /&gt; {&lt;br /&gt; \&quot;MerchantProductNo\&quot;: \&quot;testMerchantProductNo2\&quot;,&lt;br /&gt; \&quot;Name\&quot;: \&quot;testName3\&quot;,&lt;br /&gt; \&quot;Description\&quot;: \&quot;testDescription1\&quot;,&lt;br /&gt; }&lt;br /&gt; ]&lt;br /&gt; }
    # @param [Hash] opts the optional parameters
    # @option opts [PatchMerchantProductDto] :patch_merchant_product_dto 1) PropertiesToUpdate: Fields to update&lt;br /&gt;2) MerchantProductRequestModels: Products to be updated
    # @return [Array<(SingleOfProductCreationResult, Integer, Hash)>] SingleOfProductCreationResult data, response status code and response headers
    def product_bulk_patch_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ProductApi.product_bulk_patch ...'
      end
      # resource path
      local_var_path = '/v2/products'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json-patch+json', 'application/json', 'application/*+json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'patch_merchant_product_dto'])

      # return_type
      return_type = opts[:debug_return_type] || 'SingleOfProductCreationResult'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['apiKey']

      new_options = opts.merge(
        :operation => :"ProductApi.product_bulk_patch",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ProductApi#product_bulk_patch\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Upsert Products.
    # Upsert (update or create) products. The parent serves as the 'base' product of the children.<br />For example, the children could be different sizes or colors of the parent product.<br />For channels where every size and color are different products this does not make any difference<br />(the children will just be sent separately, while ignoring the parent).<br />But there are channels where the parent and the children need to be sent together, for example<br />when there is one product with a list of sizes. In this case all the product information is retrieved<br />from the parent product while the size list is generated from the children.<br /> <br />Note that the parent itself is a 'blueprint' of the child products and we do our best to make sure it<br />does not end up on the marketplaces itself. Only the children can be purchased.<br /> <br />It's not possible to nest parent and children more than one level (A parent can have many children,<br />but any child cannot itself also have children).<br /> <br />The supplied MerchantProductNo needs to be unique.<br /> <br />When \"ignoreStock\" query string parameter is set to \"true\", stock will not be updated
    # @param merchant_product_request [Array<MerchantProductRequest>] 
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :ignore_stock  (default to false)
    # @return [SingleOfProductCreationResult]
    def product_create(merchant_product_request, opts = {})
      data, _status_code, _headers = product_create_with_http_info(merchant_product_request, opts)
      data
    end

    # Upsert Products.
    # Upsert (update or create) products. The parent serves as the &#39;base&#39; product of the children.&lt;br /&gt;For example, the children could be different sizes or colors of the parent product.&lt;br /&gt;For channels where every size and color are different products this does not make any difference&lt;br /&gt;(the children will just be sent separately, while ignoring the parent).&lt;br /&gt;But there are channels where the parent and the children need to be sent together, for example&lt;br /&gt;when there is one product with a list of sizes. In this case all the product information is retrieved&lt;br /&gt;from the parent product while the size list is generated from the children.&lt;br /&gt; &lt;br /&gt;Note that the parent itself is a &#39;blueprint&#39; of the child products and we do our best to make sure it&lt;br /&gt;does not end up on the marketplaces itself. Only the children can be purchased.&lt;br /&gt; &lt;br /&gt;It&#39;s not possible to nest parent and children more than one level (A parent can have many children,&lt;br /&gt;but any child cannot itself also have children).&lt;br /&gt; &lt;br /&gt;The supplied MerchantProductNo needs to be unique.&lt;br /&gt; &lt;br /&gt;When \&quot;ignoreStock\&quot; query string parameter is set to \&quot;true\&quot;, stock will not be updated
    # @param merchant_product_request [Array<MerchantProductRequest>] 
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :ignore_stock 
    # @return [Array<(SingleOfProductCreationResult, Integer, Hash)>] SingleOfProductCreationResult data, response status code and response headers
    def product_create_with_http_info(merchant_product_request, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ProductApi.product_create ...'
      end
      # verify the required parameter 'merchant_product_request' is set
      if @api_client.config.client_side_validation && merchant_product_request.nil?
        fail ArgumentError, "Missing the required parameter 'merchant_product_request' when calling ProductApi.product_create"
      end
      # resource path
      local_var_path = '/v2/products'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'ignoreStock'] = opts[:'ignore_stock'] if !opts[:'ignore_stock'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json-patch+json', 'application/json', 'application/*+json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(merchant_product_request)

      # return_type
      return_type = opts[:debug_return_type] || 'SingleOfProductCreationResult'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['apiKey']

      new_options = opts.merge(
        :operation => :"ProductApi.product_create",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ProductApi#product_create\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete Product.
    # Delete a product based on the merchant reference.<br />Note that we do not really delete a product, as the product<br />might still be referenced by orders etc. Therefore, the references<br />used for this product cannot be reused. We do however deactivate the product<br />which means that it will not be sent to channels.
    # @param merchant_product_no [String] The MerchantProductNo of the product you wish to delete.
    # @param [Hash] opts the optional parameters
    # @return [ApiResponse]
    def product_delete(merchant_product_no, opts = {})
      data, _status_code, _headers = product_delete_with_http_info(merchant_product_no, opts)
      data
    end

    # Delete Product.
    # Delete a product based on the merchant reference.&lt;br /&gt;Note that we do not really delete a product, as the product&lt;br /&gt;might still be referenced by orders etc. Therefore, the references&lt;br /&gt;used for this product cannot be reused. We do however deactivate the product&lt;br /&gt;which means that it will not be sent to channels.
    # @param merchant_product_no [String] The MerchantProductNo of the product you wish to delete.
    # @param [Hash] opts the optional parameters
    # @return [Array<(ApiResponse, Integer, Hash)>] ApiResponse data, response status code and response headers
    def product_delete_with_http_info(merchant_product_no, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ProductApi.product_delete ...'
      end
      # verify the required parameter 'merchant_product_no' is set
      if @api_client.config.client_side_validation && merchant_product_no.nil?
        fail ArgumentError, "Missing the required parameter 'merchant_product_no' when calling ProductApi.product_delete"
      end
      # resource path
      local_var_path = '/v2/products/{merchantProductNo}'.sub('{' + 'merchantProductNo' + '}', CGI.escape(merchant_product_no.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ApiResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['apiKey']

      new_options = opts.merge(
        :operation => :"ProductApi.product_delete",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ProductApi#product_delete\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Products.
    # Retrieve all products.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :search Search product(s) by Name, MerchantProductNo, Ean or Brand&lt;br /&gt;This search is applied to the result after applying the other filters.
    # @option opts [Array<String>] :ean_list Search products by submitting a list of EAN&#39;s.
    # @option opts [Array<String>] :merchant_product_no_list Search products by submitting a list of MerchantProductNo&#39;s.
    # @option opts [Integer] :page The page to filter on. Starts at 1.
    # @return [CollectionOfMerchantProductResponse]
    def product_get_by_filter(opts = {})
      data, _status_code, _headers = product_get_by_filter_with_http_info(opts)
      data
    end

    # Get Products.
    # Retrieve all products.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :search Search product(s) by Name, MerchantProductNo, Ean or Brand&lt;br /&gt;This search is applied to the result after applying the other filters.
    # @option opts [Array<String>] :ean_list Search products by submitting a list of EAN&#39;s.
    # @option opts [Array<String>] :merchant_product_no_list Search products by submitting a list of MerchantProductNo&#39;s.
    # @option opts [Integer] :page The page to filter on. Starts at 1.
    # @return [Array<(CollectionOfMerchantProductResponse, Integer, Hash)>] CollectionOfMerchantProductResponse data, response status code and response headers
    def product_get_by_filter_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ProductApi.product_get_by_filter ...'
      end
      # resource path
      local_var_path = '/v2/products'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'search'] = opts[:'search'] if !opts[:'search'].nil?
      query_params[:'eanList'] = @api_client.build_collection_param(opts[:'ean_list'], :multi) if !opts[:'ean_list'].nil?
      query_params[:'merchantProductNoList'] = @api_client.build_collection_param(opts[:'merchant_product_no_list'], :multi) if !opts[:'merchant_product_no_list'].nil?
      query_params[:'page'] = opts[:'page'] if !opts[:'page'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'CollectionOfMerchantProductResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['apiKey']

      new_options = opts.merge(
        :operation => :"ProductApi.product_get_by_filter",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ProductApi#product_get_by_filter\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Product.
    # Retrieve a product based on the merchant reference.
    # @param merchant_product_no [String] The unique product reference used by the Merchant (sku).
    # @param [Hash] opts the optional parameters
    # @return [SingleOfMerchantProductResponse]
    def product_get_by_merchant_product_no(merchant_product_no, opts = {})
      data, _status_code, _headers = product_get_by_merchant_product_no_with_http_info(merchant_product_no, opts)
      data
    end

    # Get Product.
    # Retrieve a product based on the merchant reference.
    # @param merchant_product_no [String] The unique product reference used by the Merchant (sku).
    # @param [Hash] opts the optional parameters
    # @return [Array<(SingleOfMerchantProductResponse, Integer, Hash)>] SingleOfMerchantProductResponse data, response status code and response headers
    def product_get_by_merchant_product_no_with_http_info(merchant_product_no, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ProductApi.product_get_by_merchant_product_no ...'
      end
      # verify the required parameter 'merchant_product_no' is set
      if @api_client.config.client_side_validation && merchant_product_no.nil?
        fail ArgumentError, "Missing the required parameter 'merchant_product_no' when calling ProductApi.product_get_by_merchant_product_no"
      end
      # resource path
      local_var_path = '/v2/products/{merchantProductNo}'.sub('{' + 'merchantProductNo' + '}', CGI.escape(merchant_product_no.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'SingleOfMerchantProductResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['apiKey']

      new_options = opts.merge(
        :operation => :"ProductApi.product_get_by_merchant_product_no",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ProductApi#product_get_by_merchant_product_no\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Patch product
    # Patch products. This endpoint allows you to update single fields on a product using patch operations,<br />without having to supply the other product information.<br /><br />The format of this endpoint is a JsonPatchDocument. Examples of how this format works can be found here:<br />http://jsonpatch.com/<br /> <br />It's not possible to nest parent and children more than one level (A parent can have many children,<br />but any child cannot itself also have children).<br /> <br />The supplied MerchantProductNo needs to be unique.<br /><br /> <br />ExtraData used as translations is ignored and cannot be changed.<br /><br />Sample request:<br /> <br /> PATCH /v2/products/{merchantProductNo}<br /> {<br /> \"value\": \"Value\",<br /> \"path\": \"Name\",<br /> \"op\": \"replace\"<br /> }<br /> <br />Adding ExtraData:<br /><br /> PATCH /v2/products/{merchantProductNo}<br /> {<br /> \"value\": {\"key\": \"Key1\", \"value\": \"value1\"},<br /> \"path\": \"extraData/0\",<br /> \"op\": \"add\"<br /> }<br /> <br />Replacing ExtraData (will replace entire ExtraData collection):<br /><br /> PATCH /v2/products/{merchantProductNo}<br /> {<br /> \"value\": [{\"key\": \"Key1\", \"value\": \"value1\"}],<br /> \"path\": \"extraData\",<br /> \"op\": \"replace\"<br /> }<br /> <br />Removing all ExtraData:<br /><br /> PATCH /v2/products/{merchantProductNo}<br /> {<br /> \"path\": \"extraData\",<br /> \"op\": \"replace\"<br /> }<br /> <br /> Or:<br /> <br /> PATCH /v2/products/{merchantProductNo}<br /> {<br /> \"path\": \"extraData\",<br /> \"op\": \"remove\"<br /> }
    # @param merchant_product_no [String] The MerchantProductNo of the product you wish to patch
    # @param [Hash] opts the optional parameters
    # @option opts [Array<Operation>] :operation The JsonPatchDocument providing the operations you wish to perform on the product. &lt;br /&gt; Value contains the value you wish to set on the property you&#39;re updating (used with operations \&quot;add\&quot; and \&quot;replace\&quot;).&lt;br /&gt; Path contains the path to the property you&#39;re updating (e.g. Description). Every property in the model used for creation an updating can be used.&lt;br /&gt; Op contains the operation you wish to perform (\&quot;add\&quot;,\&quot;replace\&quot;,\&quot;remove\&quot;).&lt;br /&gt; From is only used when using the \&quot;move\&quot; operation. It refers to the source path of the value to be moved.
    # @return [SingleOfProductCreationResult]
    def product_patch(merchant_product_no, opts = {})
      data, _status_code, _headers = product_patch_with_http_info(merchant_product_no, opts)
      data
    end

    # Patch product
    # Patch products. This endpoint allows you to update single fields on a product using patch operations,&lt;br /&gt;without having to supply the other product information.&lt;br /&gt;&lt;br /&gt;The format of this endpoint is a JsonPatchDocument. Examples of how this format works can be found here:&lt;br /&gt;http://jsonpatch.com/&lt;br /&gt; &lt;br /&gt;It&#39;s not possible to nest parent and children more than one level (A parent can have many children,&lt;br /&gt;but any child cannot itself also have children).&lt;br /&gt; &lt;br /&gt;The supplied MerchantProductNo needs to be unique.&lt;br /&gt;&lt;br /&gt; &lt;br /&gt;ExtraData used as translations is ignored and cannot be changed.&lt;br /&gt;&lt;br /&gt;Sample request:&lt;br /&gt; &lt;br /&gt; PATCH /v2/products/{merchantProductNo}&lt;br /&gt; {&lt;br /&gt; \&quot;value\&quot;: \&quot;Value\&quot;,&lt;br /&gt; \&quot;path\&quot;: \&quot;Name\&quot;,&lt;br /&gt; \&quot;op\&quot;: \&quot;replace\&quot;&lt;br /&gt; }&lt;br /&gt; &lt;br /&gt;Adding ExtraData:&lt;br /&gt;&lt;br /&gt; PATCH /v2/products/{merchantProductNo}&lt;br /&gt; {&lt;br /&gt; \&quot;value\&quot;: {\&quot;key\&quot;: \&quot;Key1\&quot;, \&quot;value\&quot;: \&quot;value1\&quot;},&lt;br /&gt; \&quot;path\&quot;: \&quot;extraData/0\&quot;,&lt;br /&gt; \&quot;op\&quot;: \&quot;add\&quot;&lt;br /&gt; }&lt;br /&gt; &lt;br /&gt;Replacing ExtraData (will replace entire ExtraData collection):&lt;br /&gt;&lt;br /&gt; PATCH /v2/products/{merchantProductNo}&lt;br /&gt; {&lt;br /&gt; \&quot;value\&quot;: [{\&quot;key\&quot;: \&quot;Key1\&quot;, \&quot;value\&quot;: \&quot;value1\&quot;}],&lt;br /&gt; \&quot;path\&quot;: \&quot;extraData\&quot;,&lt;br /&gt; \&quot;op\&quot;: \&quot;replace\&quot;&lt;br /&gt; }&lt;br /&gt; &lt;br /&gt;Removing all ExtraData:&lt;br /&gt;&lt;br /&gt; PATCH /v2/products/{merchantProductNo}&lt;br /&gt; {&lt;br /&gt; \&quot;path\&quot;: \&quot;extraData\&quot;,&lt;br /&gt; \&quot;op\&quot;: \&quot;replace\&quot;&lt;br /&gt; }&lt;br /&gt; &lt;br /&gt; Or:&lt;br /&gt; &lt;br /&gt; PATCH /v2/products/{merchantProductNo}&lt;br /&gt; {&lt;br /&gt; \&quot;path\&quot;: \&quot;extraData\&quot;,&lt;br /&gt; \&quot;op\&quot;: \&quot;remove\&quot;&lt;br /&gt; }
    # @param merchant_product_no [String] The MerchantProductNo of the product you wish to patch
    # @param [Hash] opts the optional parameters
    # @option opts [Array<Operation>] :operation The JsonPatchDocument providing the operations you wish to perform on the product. &lt;br /&gt; Value contains the value you wish to set on the property you&#39;re updating (used with operations \&quot;add\&quot; and \&quot;replace\&quot;).&lt;br /&gt; Path contains the path to the property you&#39;re updating (e.g. Description). Every property in the model used for creation an updating can be used.&lt;br /&gt; Op contains the operation you wish to perform (\&quot;add\&quot;,\&quot;replace\&quot;,\&quot;remove\&quot;).&lt;br /&gt; From is only used when using the \&quot;move\&quot; operation. It refers to the source path of the value to be moved.
    # @return [Array<(SingleOfProductCreationResult, Integer, Hash)>] SingleOfProductCreationResult data, response status code and response headers
    def product_patch_with_http_info(merchant_product_no, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ProductApi.product_patch ...'
      end
      # verify the required parameter 'merchant_product_no' is set
      if @api_client.config.client_side_validation && merchant_product_no.nil?
        fail ArgumentError, "Missing the required parameter 'merchant_product_no' when calling ProductApi.product_patch"
      end
      # resource path
      local_var_path = '/v2/products/{merchantProductNo}'.sub('{' + 'merchantProductNo' + '}', CGI.escape(merchant_product_no.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json-patch+json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'operation'])

      # return_type
      return_type = opts[:debug_return_type] || 'SingleOfProductCreationResult'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['apiKey']

      new_options = opts.merge(
        :operation => :"ProductApi.product_patch",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ProductApi#product_patch\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
